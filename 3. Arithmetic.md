# Arithmetic

Now that we have built an adder, have all the necessary logic gates, and understand how the binary number system works — we can talk about how computers “calculate”.

The critically important discovery is that computers cannot **subtract**, **divide**, **multiply**, or **raise to a power** — and certainly cannot **extract roots**.  
They can only **add**.

The whole trick lies in the fact that we’ve learned to represent absolutely all the operations we need as **addition**.

---

## Subtraction and Negative Numbers

Since we cannot make the computer calculate `a - b`, we need to achieve `a + (-b)`.  
So how do we get `-b`?

Let’s assume we are working with **4-bit numbers**.  
We need to compute `5 - 5`.  
In binary, `5 = 0101`.  
To invert it, we pass every bit of the number 5 through a **not** gate and get `1010`.

Now, if we add `0101` and `1010`, we get `1111`, which equals **-0** (we’ll explain why later).  
What’s missing to get 0? A **one**.  
That’s why we always add **1** to the inverted number.

If we add `0101 + 1010 = 1111`, and then add 1, we’ll get an **overflow** — the highest bit goes beyond our 4-bit range, and we get `0000 = 0`.  
`5 - 5 = 0` — everything checks out.

---

## Two’s Complement (Additional Code)

Now it would be nice to distinguish whether a number is **positive** or **negative**.  
For that, we use **two’s complement** representation.

Let’s assume we’re working with **8-bit numbers**.  
Our range without signs is `0–255`.  
`255 = 11111111`.

When we use two’s complement, the range shifts from **-128 to +127**.  
`01111111` represents `127`, while `10000000` represents `-128`.  
As you can see, it’s the **leftmost bit** that determines the sign of the number.  
`11111111 = -1`.

---

## Multiplication

Binary multiplication is very similar to how we multiply numbers by hand in decimal form,  
but it’s much simpler since we only deal with 0s and 1s.  

The core algorithm is called **"shift and add"**.

Let’s look at an example of multiplying two 4-bit numbers: **9 (1001)** by **5 (0101)**.

- Multiplicand: `1001` (the number 9)  
- Multiplier: `0101` (the number 5)  
- Product: initially all zeros, with **double the bit width** (8 bits in this case) → `0000 0000`

### Step-by-Step Process

We analyze the bits of the multiplier from right to left:

**Step 1:**  
Rightmost bit of the multiplier = `1`.  
Since the current bit of the multiplier `(010**1**)` equals 1, we add the multiplicand (`1001`) to our product.  
**Result:** `0000 0000 + 1001 = 0000 1001`.

**Step 2:**  
Shift the multiplicand left by one bit (equivalent to multiplying by 2).  
**Multiplicand:** `10010`.

**Step 3:**  
Next bit of the multiplier = `0`.  
Since it’s 0 `(01**0**1)`, we do nothing.  
**Result:** remains `0000 1001`.

**Step 4:**  
Shift the multiplicand left again.  
**Multiplicand:** `100100`.

**Step 5:**  
Next bit of the multiplier = `1`.  
We add the multiplicand to the result:  
`0000 1001 + 100100 = 0010 1101`.

**Step 6:**  
Shift the multiplicand left again → `1001000`.

**Step 7:**  
Last bit of the multiplier = `0`.  
Do nothing again.

**Final Result:**  
`0010 1101` → in decimal, `32 + 8 + 4 + 1 = 45`.  
`9 * 5 = 45`.

**Key idea:**  
- Multiplying by 1 → simply add the number itself.  
- Multiplying by 0 → add zero.  
- Shifting left → multiply by 2.  
By combining these, the processor effectively performs multiplication.

---

## Division

Division is a more complex operation.  
One of the easiest algorithms to understand is **“restoring division”**,  
which imitates the long division method we use in school.

Let’s divide **13 (1101)** by **3 (0011)**.

### Initialization

- Dividend: `1101`  
- Divisor: `0011`  
- Quotient: `0000`  
- Remainder: `0000` (initially)

### Step-by-Step Process

The algorithm runs for as many cycles as there are bits in the dividend.

---

**Cycle 1**

- **Shift:** shift the remainder left by 1 bit and move the highest bit of the dividend into the remainder.  
  Remainder: `0001`  
  Dividend: `101`  
- **Subtract:** `0001 - 0011` → result is negative.  
- Since it’s negative, the divisor “does not fit”.  
  Write **0** into the lowest bit of the quotient → Quotient = `0000`.  
  Restore remainder: `(0001 - 0011) + 0011 = 0001`.

---

**Cycle 2**

- **Shift:** remainder = `0011`, dividend = `01`.  
- **Subtract:** `0011 - 0011 = 0000`.  
  Result is not negative → write **1** to quotient → `0001`.  
  Remainder = `0000`.

---

**Cycle 3**

- **Shift:** remainder = `0000`, dividend = `1`.  
- **Subtract:** `0000 - 0011` → negative.  
  Write **0** to quotient → `0010`.  
  Restore remainder: `0000`.

---

**Cycle 4**

- **Shift:** remainder = `0001`, dividend is empty.  
- **Subtract:** `0001 - 0011` → negative.  
  Write **0** to quotient → `0100`.  
  Restore remainder: `0001`.

---

**Final Result**

- Quotient: `0100` → decimal **4**  
- Remainder: `0001` → decimal **1**  

`13 / 3 = 4` remainder `1`

---

**Note:**  
There are faster algorithms (e.g., *non-restoring division*),  
but all of them are based on these same fundamental ideas of **bit shifts** and **subtractions**.  
Modern processors use much more complex and optimized circuitry to perform these operations in as few clock cycles as possible.
